% Script to calculate the ARFI pattern based on already calculated pressure and Q patterns.  Follows the
%	method described in Walker, JASA 105(4)1999 based on Love's book (ref. 15). After running from command window,
%   displacement pattern is displayed in place of the pressure pattern, with micrometer units instead of Pa.
% This version uses frequency-domain multiplication of the Fourier transform of the Green's function with
%   the Fourier transform of the Force field to accomplish the convolution (much faster).  The Green's function
%   is padded out with zeros to match the size of the Force field before the FFT and multiplication.  The usual
%   Green's function size is 61x61x91 mm if Dx=Dy=Dz=1 mm, which is approximately as far as the shear waves will
%   propagate if the push beam is on for 10-15 ms and the shear wave speed is 2 m/s (typical).
%
%   Changes:
%   3/21/14 - This version does NOT low-pass filter the mu values to represent inhomogeneous boundary conditions
%       (see commented section below), so it is appropriate for a homogeneous medium only.
%   3/21/14 - This version linearly shades the Green's function to implement partial phase accumulation that occurs
%       only after the spherical shear wave reaches each point.  A Green's function larger than both the model and the
%       size of this shear-wave sphere is required. The shaded Green's function is truncated to match the model size.
%   5/19/15 - Added check to make sure number of Lame coeff entered (mu) matched number of media in Modl.
%      Also asked what predominant media type was; this determines the radius of shear wavefront sphere (only one
%      unique radius allowed in this version of program).
%      Now wdisp stands as a separate file to be displayed on its own by displa7, which uses the 'ARFI displacement' 
%      selection (4th item) in the display menu in HASgui.
%   4/18/17 - Only allow ARFI calculations with a never-rotated Modl or with a currently rotated Modl.  Otherwise there
%       may be errors in Z, pfor, etc when rotated back. Also, Green's function assumes longitudinal displacement only.
%       Therefore, if Modl is rotated, must calc ARFI when rotated, then rotate wdisp back with rotateback.m.
%       Also, ARFI force-field calculations (using pfor and pref) only valid if one or less reflections implemented.
%
%   Copyright D.A. Christensen 2015.
%   May 19, 2015

if exist('pivs','var') && ~ismodlrot  % pivs exists if Modl has been rotated once; ~ismodlrot means model not rotated.
   errordlg('ARFI calculations only valid for never-rotated model or currently rotated model','ERROR','modal'); return; 
end
if numrefl>1 % pfor and pref will be inaccurate if more than one reflection is implemented.
    errordlg('ARFI calculations not valid if more than one reflection is implemented','ERROR','modal'); return; 
end
clear A* lay*  % clear some variables generated by CalcHAS to free memory; can be calculated again with new simulation.
clear Refl attmodl pback scattmodl transf randarrfine rhomodl vararray 
if Dx~=Dy || Dy~=Dz % the Green's function pattern is currently applicable only for isotropic voxel sizes.
    errordlg('For now, voxel sizes must be isotropic for convolution in ARFIcalc.','ERROR','modal'); return; 
end
if ~exist('pout','var'); 
    errordlg('Pressure must be calculated before ARFI is calculated','ERROR','modal'); return;
end

% ----- Enter Lame constants ----
prompt={'Enter Lame shear coeffs of each medium (in N/m^2):','Enter index of predominant medium type'};
titl='ARFI Parameters';  lines=2; 
if exist('mu','var'); initans={num2str(mu),'2'};    % use previous mu's if available.
else initans={num2str(3000),'2'};
end
answer3=inputdlg(prompt,titl,lines,initans,'on');
if isempty(answer3); return; end 
mu=str2num(answer3{1}); % Lame shear coeffs, mu, in N/m^2.
if length(mu)~=length(rho)
    errordlg('Number of Lame shear coeffs must match number of media types','ERROR','modal'); return;
end
mus=single(mu)*1e-6;  % convert values to N/mm^2.
mumodl=mus(Modl);
domARFImed=str2num(answer3{2});

%----- Find Force Field -----
Fprimea=real(absmodl.*(pfor.*conj(pfor./Z)))./cmodl; % force vol density due to absorption of forward beam [N/m^3].
Fprimeb=real(pref.*conj(pref./Z))./cmodl; % area density of force due to reflection at voxel interface [N/m^2].
Force=single(Fprimea*Dx*Dy*Dz*1e-9 + Fprimeb*Dx*Dy*1e-6);  % total force on voxel [N]; note that Dx, Dy and Dz are in mm.
ForceTotalN=sum(Force(:))       % note: print this value out
clear Fprimea Fprimeb  % to free memory.

%----- Load Green's Function -----
[filename10, pathname] = uigetfile('*.mat',...
    'Open gLxxx.mat file of Greens function that is larger than or same size as Modl:');
if filename10==0; filename1=''; return; end
load([pathname filename10]);
gL=single(gL/Dz);   % scale generic Green's pattern to fit the increments of the model; remember Dx=Dy=Dz, all in mm.
gLrowc=ceil(size(gL,1)/2); gLcolc=ceil(size(gL,2)/2); gLpagec=ceil(size(gL,3)/2); % centers of Green's fnct (fnct always odd).

%----- Enter Total Forcing Time Tf, then Linearly Shade Green's Function to a Sphere of Radius = Shear Speed x Tf.
prompt={'Enter total forcing time Tf (in ms):'};
titl='Forcing Time';  lines=1; 
if exist('Tf','var'); initans={num2str(Tf)};    % use previous radius if available.
else initans={num2str(10)};
end
answer4=inputdlg(prompt,titl,lines,initans,'on');
if isempty(answer4); return; end
Tf=str2num(answer4{1});     % total forcing time Tf (in ms).
betas=sqrt(mu(domARFImed)./rho(domARFImed))    % shear wave speed in dominant medium (in m/s); note print.
Rs=betas*Tf   % radius of shear-wave sphere after time Tf (in mm); note print.
Rpix=round(Rs/Dz);  % radius in pixel units.
% if ceil(Rpix)~=Rpix; errordlg('Radius must be an integer'); return; end
if size(gL,1)<2*Rpix+1 || size(gL,2)<2*Rpix+1 || size(gL,3)<2*Rpix+1
    errordlg('Max shear wavefront sphere is larger than Green''s, so use larger Green''s. Terminated.'); return;
end
RV=[-Rpix:1:Rpix]; % make vector 2*Rpix long whose center element is zero.
[Xdist,Ydist,Zdist]=meshgrid(RV,RV,RV); 
distfromcenter=sqrt(Xdist.^2+Ydist.^2+Zdist.^2); % array of distances (in pixels) from center pixel.
Rlin=1-distfromcenter./Rpix; % array whose value is 1 at center, linearly decreasing to zero at radius Rpix;
Rlin(Rlin<0)=0; % force pixels outside of radius Rpix equal to zero;
%--- Center Rlin in an array the size of gL, then use this array Rmult to linearly shade gL ---
Rmult=zeros(size(gL));
Rmult(gLrowc-Rpix:gLrowc+Rpix,gLcolc-Rpix:gLcolc+Rpix,gLpagec-Rpix:gLpagec+Rpix)=Rlin; 
gL=gL.*Rmult; % linearly shaded gL.
clear Xdist Ydist Zdist Rlin Rmult % to free memory.

% ----- Truncate Green's Function to Match Size of Force Field from Modl -----
rowbeg=floor((size(gL,1)-size(Force,1))/2); rowend=ceil((size(gL,1)-size(Force,1))/2);  % find padding sizes.
colbeg=floor((size(gL,2)-size(Force,2))/2); colend=ceil((size(gL,2)-size(Force,2))/2);
pagebeg=floor((size(gL,3)-size(Force,3))/2); pageend=ceil((size(gL,3)-size(Force,3))/2);
if rowbeg<0 || colbeg<0 || pagebeg<0
    errordlg('Modl is larger than Green''s function, so use larger Green''s function or smaller Modl. Terminated.'); return;
end
if rowbeg~=rowend || colbeg~=colend || pagebeg~=pageend
    warndlg('Green''s function is offset by one voxel since the sizes of the Force field (Modl) are not all odd','Warning','modal');
end
gtrunc=gL(rowbeg+1:end-rowend,colbeg+1:end-colend,pagebeg+1:end-pageend); % truncate gL to match size of Force field.
clear gL  % to free memory

% ----- These next lines low-pass filter mumodl to approximate boundary conditions on mu -----
% MM=single(fftn(ifftshift(mumodl))); 
% forcerowc=ceil(size(Force,1)/2); forcecolc=ceil(size(Force,2)/2); forcepagec=ceil(size(Force,3)/2); %Force centers.
% gfilt=zeros(size(Force,1),size(Force,2),size(Force,3));
% gcenter=gL(gLrowc-3:gLrowc+3,gLcolc-3:gLcolc+3,gLpagec-7:gLpagec+7);%7x7x15 center of Green's fnct weighting mask.
% gfilt(forcerowc-3:forcerowc+3,forcecolc-3:forcecolc+3,forcepagec-7:forcepagec+7)=gcenter; %gfilt is  padded gcenter.
% GF=single(fftn(ifftshift(gfilt)));
% mufilt=abs(fftshift(ifftn(MM.*GF)))/sum(gfilt(:));   % low-pass filtered mumodl, adjusted for magnitude of filter.
% clear MM GF gfilt   % to free memory

 hw3=msgbox('Wait for convolution to finish.','modal');
AA=fftn(ifftshift(Force./(8*pi*mumodl)));  % Eq. 2 in Walker or p. 187 in Love with lambda >> mu.
% AA=fftn(ifftshift(Force./(8*pi*mufilt)));  % to use mu WITH spatial filtering.
GG=fftn(ifftshift(gtrunc));
wdisp=abs(fftshift(ifftn(AA.*GG))); % overall displacement in z-direction.
clear AA GG gtrunc  % to free memory.

wdisp(Modl==1)=0;   % ignore displacement in water (not elastic).
wdisp=wdisp*1e3;  % convert to micrometers.
maxwdisp=max(wdisp(:));  % to normalize display
%pout=wdisp; % to display in place of pressure pattern (legacy).
%maxpout=max(pout(:));   % to normalize display (legacy).
close(hw3)

set(handles.listbox1,'value',4);    % view wdisp pattern.
displa7