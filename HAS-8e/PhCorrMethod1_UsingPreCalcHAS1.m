% Program for pre-calculating the PA element phases needed to correct for phase aberration at any point within an %   ip x jp x kp 3D ROI volume centered around the geometric focus. It stores the phases for each element in an%	ip x jp x kp x numelem 4D variable called PhCorr1. The phases needed for any point within that volume can %	then be obtained from this array by specifying the y,x,z order of the first three indices.  This program is pre-run%   from the COMMAND WINDOW, similar to a regular simulation, but the only output is the PhCorr1 variable and%   some configuration variables.%   The HASgui must already be open and loaded with the appropriate ERFA, param, and Modl files that pertain%   to the Modl under study. %  %	This program uses existing portions of CalcHAS_ERFA8d modified for the present use (without repeating the%   overall comments at the beginning of that script, and by deleting any unneeded lines. Note that since no %   reflections are used here, the sections related to multiple reflections are eliminated).  New lines in this program %   are indented and are inside comment borders with #########.%%   If checkbox7 has been selected, HASgui8e and later versions will ask the user to load the variable named%   PhCorr1 into the workspace when doing a simulation. When PhCorr1 is loaded, CalcHAS_ERFA8e will multiply%   the ERFA file by the PhCorr1 values found at the current focal point instead of the steering phases, to implement %   phase correction to that point using Method1. % %	This program prepares the HASgui for PhCorrMethod1 by using pre-calculation (as compared to PhCorrMethod2, %   which uses time reversal, and Method3, which uses ray tracing).%%   Changes:%   7/12/19 - Deleted unneeded lines in CalcHAS.%   7/18/19 - The values of the location of the geometrical focus (geom), the indices inside the ROI that locate the%       geom focus (relgeomfocus), and the filenames of the input ERFA file, the parameter file, and the Modl file are%       now stored along with PhCorr1 in the output .mat file (following Sam Adams' modifications).%       When CalcHAS_ERFA8e is evenually run, they are compared to the current values.  If any is different,%        the phase correction is bypassed since the PhCorr1 values are invalid.%%	Copyright D.A. Christensen 2019.%		July 18, 2019% -----------------------------------------------if ~exist('Modl','var')             errordlg('The Modl.mat file must be read in before calculating.','ERROR','modal');return; endoffsetxmm=str2double(get(handles.edit15,'string'));  % offsets in mm; get values from gui.offsetymm=str2double(get(handles.edit16,'string'));xaxiserfaoffs=xaxiserfa+offsetxmm; yaxiserfaoffs=yaxiserfa+offsetymm;   % adjust axes for offsets, all in mm.if Dyerfa>Dy || Dxerfa>Dx     warndlg(['The sample spacing on the ERFA plane is more than that of the Modl. '...         'Should use a higher resolution ERFA file.'],'','modal'); uiwait; end clear Aprime layxs1 layxs2 M2 pfor pout ptot transf Aprimeback Q Refl Z ind pback pref wdisp; % will recalc below.%  ############ Find size of phase correction ROI volume  ################    answer9=inputdlg('Chose ip,jp,kp size of PhCorr volume around geom focus (must be odd)','PhCorr Vol Size', 1, ...            {'41, 41,41'});        if isempty(answer9); return; end        phsize=str2num(answer9{1}); ip=phsize(1); jp=phsize(2); kp=phsize(3);                if 2*round(ip/2)==ip || 2*round(jp/2)==jp ||  2*round(kp/2)==kp             errordlg('The dimensions of the PhCorr volume must be odd integers','','modal'); uiwait;        return; end            tstart = tic; % Start clock        %  ###################################################################[lmax,mmax,nmax] = size(Modl);  % The size of the model (lmax,mmax,nmax) sets the size of the simulation space.f=fMHz*1e6;	% convert to Hz.%  ############ Initialize phase correction 'for' loop for PA elements ################        geomindx=round((geom(1)/Dx)+0.5+(sm(2)/2)); % indices of geometric focus.        geomindy=round((geom(2)/Dy)+0.5+(sm(1)/2));        geomindz=round((geom(3)/Dz));                % Determine the ranges of indices used for ROI; note (y,x,z) order:        irng=floor(geomindy - (ip - 1)/2):floor(geomindy + (ip - 1)/2); % this puts center of (odd) volume at geom focus.        jrng=floor(geomindx - (jp - 1)/2):floor(geomindx + (jp - 1)/2);        krng=floor(geomindz - (kp - 1)/2):floor(geomindz + (kp - 1)/2);                %  Limit ranges to include only indices that are inside Modl; Note: ROI might not be centered on g.f. anymore:        irng = irng((irng >= 1) & (irng <= lmax));        jrng = jrng((jrng >= 1) & (jrng <= mmax));        krng = krng((krng >= 1) & (krng <= nmax));                %   Find relative indices inside the (perhaps uncentered) ROI array that contain the geom focus:        relgeomfocusy = min( (ip-1)/2 + 1, geomindy);     % note (y,x,z) order:        relgeomfocusx = min( (jp-1)/2 + 1, geomindx);        relgeomfocusz = min( (kp-1)/2 + 1, geomindz);        relgeomfocus = [relgeomfocusy, relgeomfocusx, relgeomfocusz];  % vector to be saved along with PhCorr1.            numelem=size(perfa,3); % number of transducer elements        PhCorr1=single(zeros(length(irng),length(jrng),length(krng),numelem));  % preallocate memory        nlast = min([ceil(geomindz + kp/2), nmax]);     % last n/z slice to be computed, since only need to find        sizevol = [size(Modl,1) size(Modl,2) nlast];      %     ... phases to far end of ROI.           % This section moved here to above phase correction 'for' loop since need to preallocate only once, and        %                      also only over smaller vol given by sizevol.        % Preallocate memory of 3D variables used later inside slice 'for' loop for speed; also make single precision.        % These 3D variables used later in calculations or debugging, but some variables are 2D to save memory.        cmodl=zeros(size(Modl),'single');   % speed of sound; needed for ARFI calculation (but could recalc if mem tight)        absmodl=zeros(size(Modl),'single');  % absorption; needed for ARFI and Q calculation (could recalc if mem tight)        Z=zeros(sizevol,'single');       % acoustic  impedance; needed for ARFI and Q calculation (could recalc).        Refl=zeros(sizevol,'single');    % reflection coefficient; saved for backward wave calculation (could recalc).        sqrtexpon=zeros(sizevol,'single');  % sqrt(1-alpha_sqr-beta_sqr); used in transf, r and rp.        transf=zeros(sizevol,'single');  % transfer function; needed for backward wave propagation.        Aprime=zeros(sizevol,'single');    % angular spectra; used for debugging with pout=Aprime (could make matrix)        pfor=zeros(sizevol,'single');	% pressure array, forward propagation.        pref=zeros(sizevol,'single');        % back reflection        pprime=zeros(sizevol,'single');      % after passage through thin space-domain layer.        bprime=zeros(1,nlast);   % vector of mean propagation coefficient.        dx=Dx/1000;   dy=Dy/1000;   dz=Dz/1000; % convert to meter units (lowercase in meters);        vararray=ones(size(Modl),'single'); %  no scattering assumed here (revisit?).     for nel=1:1:numelem         % START of 'for' loop for each PA element          serfa=perfa(:,:,nel)*sqrt(Pr); % ###############  End of changes in this phase correction section #################        % Interpolate summed erfa onto smaller grid to match pp. Note conj to account for R-S.  phasor_interp2 is custom.ppe=conj(phasor_interp2(xaxiserfaoffs,yaxiserfaoffs,serfa,xaxisinterp,yaxisinterp','*linear',0)); ferfa=fftshift(fft2(ppe));   % into freq domain to allow propagation to a different distance between ERFA and model.% These next lines change the distance from the ERFA plane to front face of Modl, depending on gui input.    % Note that mmax is the max x index, lx is the extent of model in x in meters, and bprime is the mean    % propagation constant.emdist=d-sx;  % distance to propagate from ERFA plane to front of Modl; okay to be negative.bprimeerfa=2*pi*f/c0;  % region in front of Modl is water, so mean bprime = omega/c0.alpha=((1:mmax)-ceil(mmax/2))*(2*pi/(bprimeerfa*lx));   % vector of alpha in water (so use bprimeerfa).beta=((1:lmax)-ceil(lmax/2))*(2*pi/(bprimeerfa*ly));         % vector of beta in water.[alpha_sq,  beta_sq] = meshgrid(alpha.^2, beta.^2);   % lmax by mmax matrices for water transfer function.expon=1 - alpha_sq - beta_sq;   % inside sqrt part of exponent in transfer function below. When expon neg,       % evanescent waves will decay for positive emdist, but will blow up in the backward direction for negative      % emdist. So the next lines filter out those evanescent waves. (Note: Since the direction cosines alpha =      % fx times lambda and beta = fy times lambda, alpha and beta can be > 1 for high spatial frequencies caused      % by spatial details that are < lambda. Then 1 - alpha_sq - beta_sq will be negative and transfer function will      % result in decaying expon waves for positive emdist, but increasing waves for neg emdist.)if emdist<0    transferfa=zeros(lmax,mmax);    ind2=find(expon>0);    transferfa(ind2)=exp(1i*bprimeerfa*emdist*sqrt(expon(ind2)));else    transferfa=exp(1i*bprimeerfa*emdist*sqrt(expon));endpp=ifft2(ifftshift(ferfa.*transferfa));  % pressure matrix at front face of model. %  -------- This section initializes for HAS calculations ----------%           (Note: preallocation section has been moved earlier)if length(unique(Modl)) > min([length(c),length(a),length(aabs),length(rho),length(randvc)])...        || length(a) ~= length(aabs) errordlg('The number of media types in the acoustic parameter files does not match the number of media in Modl')return; end% Populate 3D property arrays; convert units from [Np/cm*MHz] to [Np/m]; assume linear in f [in MHz].absmodl=aabs(Modl)*1e2*fMHz;    % aabs(i) is pressure absorption coefficient (no random variation in it now).cmodl=c(Modl);    %  speed of sound (no random variation in it now).if min(min(min(cmodl)))==0; error ('Some speed of sound values are zero.'); end    % Set up values for (virtual) layer 0 -- assume water in region in front of modl.A0=fftshift(fft2(pp));    % pp is pressure pattern on front plane of modl.bprime0=2*pi*f/c0;    % layer 0 is water, so average bprime0 = omega/c0 (same as bprimeerfa).Z0=rho0*c0;   % impedance of water.                                                                      %----- Start of forward increment in n (slice number) ( + z propagation direction) -------------% ########## Add waitbar outside each element's phase-correction loop, and proceed only to nlast ##########     hwb1=waitbar(0,['Calculating beam from element #', num2str(nel)]);    for n=1:nlast       % START of 'for' loop for each PA element     % #################################################################################             % Set up 2D acoustic property matrices (to save memory) for this particular plane:    attmodl=a(Modl(:,:,n))*1e2*fMHz;     % a(i) is pressure total attenuation coefficient (assume linear freq dep).     rhomodl=rho(Modl(:,:,n));  % rho is density.	b=2*pi*f./cmodl(:,:,n);    % 2D matrix of propagation constant.    Z(:,:,n)=rhomodl.*cmodl(:,:,n).*(1-1i*attmodl./b);% impedance of layer n (slightly complex-be careful in P calcs).        if n==1               Refl(:,:,1)=(Z(:,:,1) - Z0)./(Z(:,:,1) + Z0);     % layer 1 exception.            pforb=pp.*(1+Refl(:,:,1));   %  pforb due to source pressure pattern pp.                                                          %  pforb--similar to pbackb--added 3/10/17; see "Latest Diagram....        else             Refl(:,:,n)=(Z(:,:,n) - Z(:,:,n-1))./(Z(:,:,n) + Z(:,:,n-1));  % pressure reflection coeficient from layer n.            pref(:,:,n-1)=Refl(:,:,n).*pfor(:,:,n-1);   % reflected pressure from forward propagation.            pforb=pfor(:,:,n-1).*(1+Refl(:,:,n));             end    bprime(n)=sum(sum(abs(pforb).*b))./sum(sum(abs(pforb)));    % mean propagation constant,                                                     % averaged over entire plane area, weighted by expected beam region.    alpha=((1:mmax)-ceil(mmax/2))*(2*pi/(bprime(n)*lx));   % vector of alpha for this layer.    beta=((1:lmax)-ceil(lmax/2))*(2*pi/(bprime(n)*ly));         % vector of beta. See earlier comments on alpha, beta.    [alpha_sq,  beta_sq] = meshgrid(alpha.^2, beta.^2);   % lmax by mmax matrices for transfer function (and r, rp).    sqrtexpon(:,:,n) = sqrt(1 - alpha_sq - beta_sq);  % sqrt part of exponent in transfer function and in r, rp below.              % (Even if it is imag when arg negative, evanescent waves will decay since bprime and dz always pos).    transf(:,:,n)=exp(1i*bprime(n).*dz.*sqrtexpon(:,:,n));            % Use Full Integration (equations from Scott Almquist):        r = dz./sqrtexpon(:,:,n);    % oblique path length as function of cos of angles (alpha, beta).    rp = dz.*sqrtexpon(:,:,n);    % phase path length as function of cos of angles (alpha, beta).    complex_idx = imag(rp) > 0;    rp(complex_idx) = 0; r(complex_idx) = 0;  % to avoid exp increasing when r's are complex and dbvect is neg.    bvect = 2*pi*f./c;     % propagation constant vector; length = number of media types in model (units 1/m).    avect = a*1e-4*f;   % attenuation vector; length = number of media types in model (units Np/m) (linear freq dep).    dbvect = bvect - bprime(n);  % excess of media prop constant over mean prop constant (bprime); can be neg.      %  These next lines do full numerical integration of the exponential propagation in the space domain,         %  weighted by A (see Eq. 4, Working Notes1, 5/8/06, revised 4/29/16).    pprimeterm = NaN(1,length(a));  % preallocate vector; use NaN to detect error if pprimeterm not fully found.    for kk = unique(Modl(:,:,n))'     % find media type integers in this layer of the Modl (note col vector).        if n==1 || sum(sum(abs(A)))==0            Asum=sum(sum(abs(A0)));     %  Asum is used to normalize weighted exponentials; layer 1 exception here.            pprimeterm(kk)=sum(sum(exp(1i*dbvect(kk).*rp).*(exp(-avect(kk).*r)).*abs(A0)))/Asum;        else            Asum=sum(sum(abs(A)));       % A is an lmax by mmax matrix of ang spectrum, found in previous loop cycle.            pprimeterm(kk)=sum(sum(exp(1i*dbvect(kk).*rp).*(exp(-avect(kk).*r)).*abs(A)))/Asum;        end    end        pprime=pforb.*pprimeterm(Modl(:,:,n)).*vararray(:,:,n); % space-domain effects; vary by random amt (Approach C).    Aprime(:,:,n) = single(fftshift(fft2(pprime)));	% complex Eq (8); wraparound fft.    A = Aprime(:,:,n).*transf(:,:,n);	   % Eq (9rev).    pmat = single(ifft2(ifftshift(A)));	  % Eq (10).           pfor(:,:,n)=pmat;    waitbar(n/nlast)end% --------- End of forward propagation -------------------------- % ####################  Additions for phase correction ###########################         PhCorr1(:,:,:,nel)=angle(pfor(irng, jrng, krng));        close(hwb1)        disp(['Element ' num2str(nel) ' calculated. Time elapsed (s): ' num2str(toc(tstart))]);     end  % END of 'for' loop for each PA element        toc(tstart);        truncfilename1=filename1(6:14); % strip Modl and last part from name of Modl file loaded earlier.        [newfile,newpath] = uiputfile(strcat('PhCorr1_specifier_' ,truncfilename1,'.mat'),'Save PhCorr1 file?');        if newfile~=0                % Record the names of the files used to generate this PhCorr volume:        erfafilenm = filename;  paramfilenm = filename2;  modlfilenm = filename1;        geom1 = geom; % location of geom focus at time of PreCalc.                     fullfile=[newpath newfile];         save(fullfile, 'PhCorr1','relgeomfocus','geom1','erfafilenm','paramfilenm','modlfilenm', '-mat') % Save in .mat file            end % ####################  End of phase correction additions  ############################