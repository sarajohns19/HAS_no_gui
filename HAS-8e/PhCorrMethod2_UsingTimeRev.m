%  Program for calculating the PA element phases needed to correct for phase aberration at the one current focal%   point using time reversal--that is, backward propagating a point source at the focal point, including steering,%   back to the volume surrounding the transducer. The back-propagated pressure pattern is then interrogated%   to find the average of the phases within each transducer element, whose centers are found from ElemLoc file. %%   If checkbox8 has been selected in HASgui8e and later versions, this program will run as a base workspace %   script and produce a set of phase variables PhCorr2 for each element to implement phase correction.%	This program uses a streamlined version of CalcHAS_ERFA8e modified for the present use by only back-%   propagating (with angular spectrum) a point source located at the desired focal point. This program is called %   inside the full CalcHAS_ERFA8e program. Un-needed lines in CalcHAS_ERFA8e have been erased.%%   The back-propagated waves are confined within the size of Modl, so if the Modl is not large enough to%   span the lateral extent of the transducer, some elements will not be within the back-propagated wavefront%   and will their phases will be set artificially to zero.  To avoid this, the Modl needs to be padded on its sides%   (with water) enough to cover the elements.  This is done in this program by the user via an input box.%%	This program follows Method2 by using time reversal (as compared to Method1, which pre-calculates%    beams from each element independently into the focal volume, and Method3, which uses ray tracing).%%   Changes:%   6/20/29 - Added averaging of the phases within each element (assumed of size 2*relem x 2*relem) using a%    phasor approach to finding the mean.  This change improved the S/N and significantly reduced the effects of%    aliasing from neighboring virtual sources.%%	Copyright D.A. Christensen 2019.%		June 20, 2019% -----------------------------------------------if isPA==1 % finding phases makes sense only if transducer is a phased array.  % This section temporarily pads Modl to avoid missing elements and reduces aliasing when back propagated.prompt={'Number of Voxels to Pad Modl EACH Side:'}; titl='Pad Modl?';  lines=1;  initans={num2str(0)};answer7=inputdlg(prompt,titl,lines,initans,'on');if isempty(answer7); set(handles.checkbox8,'value',0); return; endpadsize=round(str2double(answer7{1})); % number of voxels to pad Modl with 1's on both sides of row and col.Modlpd=padarray(Modl,[padsize,padsize,0],1,'both'); % build a new larger Modl to avoid aliasing.tstart = tic;hwb7=waitbar(1,'<----- Propagating Back Thru Modl for Time Reversal','Name','Time Reversal');[lmaxt,mmaxt,nmaxt] = size(Modlpd); %The size of new model (lmaxt,mmaxt,nmaxt) sets the size of the simulation.if 2*round(lmaxt/2)==lmaxt || 2*round(mmaxt/2)==mmaxt    errordlg (['The i and j dimensions of the Modl MUST be odd integers for phase correction Method2a. '...        'So pad the original Modl with MakeModlOdd.m.'],'ERROR','modal')set(handles.checkbox8,'value',0); return; enddx=Dx/1000;   dy=Dy/1000;   dz=Dz/1000; % convert to meter units (lowercase in meters);lxt=(mmaxt-1)*dx;  lyt=(lmaxt-1)*dy;    % lengths of sides of new model, in m units.focusindv=round( (geom(2) + vmm)/Dy + 0.5 + (sm(1)/2) + padsize );  % y index of new focus in padded Modlpd;  focusindh=round( (geom(1) + hmm)/Dx + 0.5 + (sm(2)/2) + padsize );  % distances in mm.focusindz=round( (geom(3) + zmm)/Dz);% Determine array dimensions neededsizevol = [size(Modlpd,1), size(Modlpd,2), (focusindz + 1)];% Preallocate memory of 3D variables inside loop for speed; also make single precision.Z=zeros(sizevol,'single');       % acoustic  impedance.Refl=zeros(sizevol,'single');    % reflection coefficient.Aprimeback=zeros(sizevol,'single');  % spectrum.pback1=zeros(sizevol,'single');         % pressure array, back propagation.vararray=ones(sizevol,'single'); % if no scattering.bvect = 2*pi*f./c;     % propagation constant vector; length = number of media types in model (units 1/m).avect = a*1e-4*f;   % attenuation vector; length = number of media types in model (units Np/m) (linear freq dep).pback1(focusindv,focusindh,focusindz)=1e5;   % put a  POINT SOURCE only at intended focus.pback1(:,:,nmax)=0;   %  initialize the pressure at the back plane (unnecess since memory allocation did it).% % % To use a wider spot in water instead of point source for Time Rev, find pfoc pattern and uncomment.% % pback1(:,:,focusindz)=padarray(pfoc,[padsize,padsize,0],1,'both');  A=0; waitbar(0.95);     % Populate 3D property arrays; convert units from [Np/cm*MHz] to [Np/m]; assume linear in f [in MHz]. absmodl=aabs(Modlpd)*1e2*fMHz;    % aabs(i) is pressure absorption coefficient (no random variation in it now). cmodl=c(Modlpd);    %  speed of sound (no random variation in it now). if min(min(min(cmodl)))==0; error ('Some speed of sound values are zero.'); end  %------------ Start of backward increment in n (slice number) ( -z propagation direction) THROUGH Modlpd -------------for n=nmaxt-1:-1:1     % start at nmaxt-1 since pback=0 at back boundary.   if any(any(pback1(:,:,n+1)))   % do the following only if there is pressure being backward-propagated in this plane.                    % Set up 2D acoustic property matrices (to save memory) for this particular plane:        attmodl=a(Modlpd(:,:,n))*1e2*fMHz;     % a(i) is pressure total attenuation coefficient (assume linear freq dep).         rhomodl=rho(Modlpd(:,:,n));  % rho is density.        scattmodl=attmodl-absmodl(:,:,n);    % pressure scatt coefficient = atten - abs. REVISIT later.        b=2*pi*f./cmodl(:,:,n);    % 2D matrix of propagation constant.        Z(:,:,n)=rhomodl.*cmodl(:,:,n).*(1-1i*attmodl./b);% impedance of layer n (slightly complex).        Refl(:,:,n+1)=(Z(:,:,n+1) - Z(:,:,n))./(Z(:,:,n+1) + Z(:,:,n));  % pressure reflection coeficient from layer n+1 .                                                          % (will give wrong Refl value (-1) for nmaxt, but that value is never used.)                           pbackb=pback1(:,:,n+1).*(1-Refl(:,:,n+1)) ;                 bprime(n)=sum(sum(abs(pbackb).*b))./sum(sum(abs(pbackb)));    % mean propagation constant,                                                         % averaged over entire plane area, weighted by expected beam region.        alpha=((1:mmaxt)-ceil(mmaxt/2))*(2*pi/(bprime(n)*lxt));   % vector of alpha for this layer.        beta=((1:lmaxt)-ceil(lmaxt/2))*(2*pi/(bprime(n)*lyt));         % vector of beta. See earlier comments on alpha, beta.        [alpha_sq,  beta_sq] = meshgrid(alpha.^2, beta.^2);   % lmax by mmax matrices for transfer function (and r, rp).        expon = 1 - alpha_sq - beta_sq;  %  exponent in transfer function and in r, rp below.        %        transf=zeros(lmaxt,mmaxt);        %        ind2=find(expon>0);        %        transf(ind2)=exp(1i*bprime(n).*dz.*sqrt(expon(ind2)));         transf=exp(1i*bprime(n).*dz.*sqrt(expon));    % dz positive, so no evanescent  exponential incr possible.        % Use Full Integration.        r = dz./sqrt(expon);    % oblique path length as function of cos of angles (alpha, beta).        rp = dz.*sqrt(expon);    % phase path length as function of cos of angles (alpha, beta).        complex_idx = imag(rp) > 0;        rp(complex_idx) = 0; r(complex_idx) = 0;  % to avoid exp increasing when r's are complex and dbvect is neg.        dbvect = bvect - bprime(n);  % excess of media prop constant over mean prop constant (bprime); can be neg.                                                        % bvect and avect are same as calculated earlier.                %  These next lines do full numerical integration of the exponential propagation in the space domain,             %  weighted by A (see Eq. 4, Working Notes1, 5/8/06, revised 4/29/16).        pprimeterm = NaN(1,length(a));  % preallocate vector; use NaN to detect error if pprimeterm not fully found.        for kk = unique(Modlpd(:,:,n))'     % find media type integers in this layer of the Modl (note col vector).            if A==0                 pprimeterm(kk)=1;       % to avoid dividing by zero.            else                Asum=sum(sum(abs(A))); % A is lmax by mmax matrix of ang spectrum, found in previous loop cycle.                pprimeterm(kk)=sum(sum(exp(1i*dbvect(kk).*rp).*(exp(-avect(kk).*r)).*abs(A)))/Asum;            end        end                pbackprime=pbackb.*pprimeterm(Modlpd(:,:,n)).*vararray(:,:,n);     % backward prop in space domain.           Aprimeback(:,:,n)=single(fftshift(fft2(pbackprime)));	  % complex Eq (8); wraparound fft.        A=Aprimeback(:,:,n).*transf;	    % Eq (9rev) in reverse direction.        pmat=single(ifft2(ifftshift(A)));	% Eq (10).        pback1(:,:,n)=pmat;        waitbar(n/nmaxt)   endendclose(hwb7);% ----- End of backward propagation to front face of Modl. At this plane, the pressure pattern is pback1(:,:,1) -----hwb8=waitbar(1,'<----- Propagating Back to Transducer for Time Reversal','Name','Time Reversal');%   Set up new Modlxt between the transducer and front face of Modlxt:nxtmax=round(dmm/Dz);    % max size of extended Modlxt grid in z-direction.            %   dmm is distance from rear of transducer to the front of Modl; see 5/1/19 sketch.Modlxt=ones(lmaxt,mmaxt,nxtmax); % build and fill extended Modlxt with WATER medium.pbackxt=zeros(size(Modlxt),'single');   % preallocate memory for the pressure pattern in Modlxt.pbackxt(:,:,end+1)=0;       % add layer that overlaps with front face of Modlpd.% Set up variables for backward propagation through new Modlxt to transducer in water. % Note that mmaxt is the max x index, lx is the extent of model in x in meters; similarly for lmaxt and ly.%   bprime is the mean propagation constant in water. Use 'erfa' as example in water.bprimeerfa=2*pi*f/c0;  % region in front of Modl is water, so mean bprime = omega/c0.alpha=((1:mmaxt)-ceil(mmaxt/2))*(2*pi/(bprimeerfa*lxt));   % vector of alpha in water (so use bprimeerfa).beta=((1:lmaxt)-ceil(lmaxt/2))*(2*pi/(bprimeerfa*lyt));         % vector of beta in water.[alpha_sq,  beta_sq] = meshgrid(alpha.^2, beta.^2);   % lmax by mmax matrices for water transfer function.expon=1 - alpha_sq - beta_sq;   % inside sqrt part of exponent in transfer function below.%   transferfa=zeros(lmaxt,mmaxt);%   ind2=find(expon>0);%   transferfa(ind2)=exp(1i*bprimeerfa*dz*sqrt(expon(ind2)));transferfa=exp(1i*bprimeerfa*dz*sqrt(expon));   %--- Start of backward increment in nxt ( -z propagation direction) through Modlxt (water to xducer)  -----pbackxt(:,:,nxtmax+1)=pback1(:,:,1); % start with front face of Modl, assumed in water (so ignore reflection there).for nxt=(nxtmax):-1:1   % nxt = 1 at back face of transducer.    pbackprime=pbackxt(:,:,nxt+1);    % pressure at front of current layer is same as at end of previous layer.    Aprimebackxt=single(fftshift(fft2(pbackprime)));	  % complex Eq (8); wraparound fft.    A=Aprimebackxt.*transferfa;	    % Eq (9rev) in reverse direction.    pbackxt(:,:,nxt)=single(ifft2(ifftshift(A)));    waitbar(nxt/nxtmax)end  % -- Now find the locations of the transducer elements inside Modlxt --thvect=ElemLoc(:,1);   phivect=ElemLoc(:,2);    % to center of each element.        numelem=size(thvect,1);        dthphi = Dx/Rmm; nang = round(relem*1e3/Dx);    % angle increment and number of increments.        % --- This section averages the phases within each element to improve S/N and reduce effect of aliasing---       phasemat = zeros(2*nang+1 , 2*nang+1);  % preallocate memory.PhCorr2=zeros(1,numelem);      num_elemoutside = 0;     % total number of transducer elements outside of Modl space; start with 0.for g=1:numelem    angrange = -nang*dthphi:dthphi:nang*dthphi;    for gth=1:2*nang+1        thmat=thvect(g) + angrange(gth);        for gphi=1:2*nang+1            phimat=phivect(g) + angrange(gphi);            %  x,y values are mm distances away from the central Modlxt axis, z value is distance back from geom focus.            elemdisty= Rmm.*sin(thmat) + offsetymm ;   % add transducer axis offset from central Modlxt axis, if any.            elemdistx= -Rmm.*cos(thmat).*sin(phimat) + offsetxmm; % HAS x-axis opposite direction from ERFAmaker.            elemdistz= Rmm.*cos(thmat).*cos(phimat);   % see 5/1/19 sketch of the axes locations.            elemindy= round(elemdisty/Dy + (lmaxt +1)/2);     % now convert to indices in extended Modlxt grid.            elemindx= round(elemdistx/Dx + (mmaxt +1)/2);                elemindz= round((Rmm-elemdistz)/Dz) +1;     % start of nxt index is at 1, not 0.              if elemindy>lmaxt || elemindy<1 || elemindx>mmaxt || elemindx<1 || elemindz>nxtmax                phasemat(gth,gphi) = nan;            else            phasemat(gth,gphi) = angle(pbackxt(elemindy,elemindx,elemindz));            end        end    end    phsors=exp(1i*phasemat);    % now average angle in phasor language to avoid discontinuity near 0 and 2pi.    meanphsors=mean(mean(phsors,'omitnan'),'omitnan');    if isnan(meanphsors)         PhCorr2(g) = 0; num_elemoutside = num_elemoutside+1;   % ignore phase correction if element outside Modl.    else        PhCorr2(g) = atan2(imag(meanphsors),real(meanphsors));      endendif num_elemoutside > 0 warndlg([num2str(num_elemoutside) ' elements are outside of Modl reach, so zero phase is set for those'...    ' elements. Phase correction will not be accurate. Should run again and pad model correspondingly or increase'...    ' distance between transducer and model.'],'','modal'); uiwait;endclose(hwb8)angpgvect=shiftdim((exp(+1i*PhCorr2)),-1);disp(['Phase aberration correction calculation time: ' num2str(toc(tstart)) ' s']);clear Modlpd Z Refl sqrtexpon Aprimeback absmodl scattmodl cmodl alpha_sq beta_sq expon vararray transf A pmat ...    Modlxt transferfa Aprimebackxt  phasemat % to free memory of large arrays. else    warndlg('Transducer is not phased array, so no phase correction applicable','','modal'); uiwait;    set(handles.checkbox8,'value',0);end